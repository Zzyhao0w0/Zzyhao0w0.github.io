+++
title = "What is an optimistic lock?"
description = "Use optimistic locks to feel it"
date = 2024-06-17

[taxonomies]
categories = ["study"]
tags = ["database"]

+++


## 什么是乐观锁？

在关系型数据库中，**乐观并发控制**(`Optimistic Concurrency Control`)是一种并发控制的方法
乐观锁是假设即使在并发的操作时不会造成冲突的，所以并不会去对这个表或者这行加锁(乐观锁是一种思想，并不是一个实质的实现)，而是在对数据进行更新的时候，才会正式的对数据的冲突进行检测，如果发现冲突了，则会返回冲突消息，让客户端进行下一步操作，比如说重试

## 怎么实现乐观锁？

我们说乐观锁并不是一种具体实现，而是一种思想，那么怎么样可以实现一个乐观锁呢？

有两种比较常见的方法:

### 使用数据版本控制(version)

1. 这是一种比较常见的实现方法，通过在表中添加一个version字段作为数据版本的记录，每当一个数据发生改变的时候，都会让version+1
2. 当我们读出数据的时候(必须包括version字段)，做出更新然后提交的时候，就需要用当前的version和数据库的version字段做出比较，如果两个字段对的上就会更新的上，如果不对的话，说明当前数据版本已经过时了，也就是有其他的操作修改过这个数据，更新就失败了
3. `update table set price = price + 1, version = version + 1 where version = ? AND id = ?`

### 使用时间戳(timestamp)
1. 这种方法其实对比数据版本控制来说其实也是一样的原理，如果更新时间和获取到的数据更新时间不一致就不予更新
2. `update table set price = price + 1, updated = unix_timestamp(now()) where updated = ? AND id = ?`

## 优点和缺点

优点: 在读多写少的并发场景下，可以避免数据库加锁的开销，提高Dao层的响应性能

缺点： 在写多读少的并发场景下，即在写操作竞争激烈的情况下，会导致CAS多次重试，冲突频率过高，导致开销比悲观锁更高

在悲观锁和乐观锁的抉择中，我们可以从下面三个因素来考虑:

1. 响应速度： 如果Dao层需要非常高的响应速度，尤其是读多写少的场景下，那我们就可以采用乐观锁方案，降低数据库锁的开销，提供并发量
2. 冲突频率： 如果冲突频率非常高，那么我们就可以采用悲观锁，保证成功率；毕竟如果冲突频率大，乐观锁会需要多次重试才能成功，代价可能会大大增加
3. 重试代价： 如果重试代价大，比如说重试过程的代码执行非常耗时，那么此时我就不建议使用乐观锁了，还不如直接上悲观锁来了爽快
